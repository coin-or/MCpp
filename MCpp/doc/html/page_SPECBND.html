<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MC++: Eigenvalue Arithmetic for Factorable Functions</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://www.mathjax.org/mathjax/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MC++
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('page_SPECBND.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Eigenvalue Arithmetic for Factorable Functions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="author"><dt><b>Author:</b></dt><dd>Nikola Peri&cacute;, Akshay Shah, Jai Rajyaguru &amp; Beno&icirc;t Chachuat</dd></dl>
<p>Given a factorable, multivariate function \(f:\mathbb{R}^n\to\mathbb{R}\), that is twice-continuously differentiable on a box \(X:=[x^{\rm L},x^{\rm U}]\), M&ouml;nnigmann's technique [M&ouml;nnigmann, 2008; 2011] provides a means for computing spectral bounds of its Hessian matrix \(H_f(x)\) at any point \(x\in X\)&mdash;without actually computing \(H_f(x)\). Applications of this technique are in determining whether a function is convex or concave on a particular domain, as well as in constructing convex/concave relaxations for complete search approaches in global optimization. Alternative techniques for determining spectral bounds include the interval variant of Gershgorin's circle criterion [Adjiman <em>et al.</em>, 1998] as well as Hertz &amp; Rohn's method [Hertz, 1992], which rely on an interval enclosure of the set of all possible Hessian matrices \([H_f] \supseteq \{H_f(x) \mid x\in X\}\). See also <a class="el" href="page_MCCORMICK.html">McCormick Relaxation Arithmetic for Factorable Functions</a> for an alternative way of constructing convex/concave relaxations.</p>
<p>The class <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a> provides an implementation of eigenvalue arithmetic. We note that mc::SpecBnd is <b>not a verified implementation</b> in the sense that rounding errors are not accounted for in propagating the spectral bounds.</p>
<p>The implementation of <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a> relies on the operator/function overloading mechanism of C++. This makes the computation of spectral bounds both simple and intuitive, similar to computing function values in real arithmetics. Moreover, <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a> can be used as the template parameter of other available types in MC++; for instance, <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a> can be used in order to propagate spectral bounds on the remainder term of Taylor variable <a class="el" href="classmc_1_1TVar.html" title="C++ class for Taylor model computation of factorable function - Taylor model propagation.">mc::TVar</a>. Likewise, <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a> can be used as the template parameter of the types fadbad::F, fadbad::B and fadbad::T of <a href="http://www.fadbad.com/fadbad.html">FADBAD++</a> for computing spectral bounds of either the partial derivatives or the Taylor coefficients of a factorable function too (see <a class="el" href="page_SPECBND.html#sec_SPECBND_fadbad">How do I compute spectral bounds of the partial derivatives or the Taylor coefficients of a factorable function using FADBAD++?</a>).</p>
<p>mc:Specbnd is itself templated in the type used to propagate the necessary bounds. By default, <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a> can be used with the non-verified interval type <a class="el" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function.">mc::Interval</a> of MC++. For reliability, however, it is strongly recommended to use verified interval arithmetic such as <a href="http://www.ti3.tu-harburg.de/Software/PROFILEnglisch.html">PROFIL</a> (header file <code><a class="el" href="mcprofil_8hpp_source.html">mcprofil.hpp</a></code>) or <a href="http://www.math.uni-wuppertal.de/~xsc/software/filib.html">FILIB++</a> (header file <code><a class="el" href="mcfilib_8hpp_source.html">mcfilib.hpp</a></code>). The types <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> and <a class="el" href="classmc_1_1TVar.html" title="C++ class for Taylor model computation of factorable function - Taylor model propagation.">mc::TVar</a> can also be used as template parameters of <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a>, thereby making it possible to compute, respectively, convex/concave bounds and Taylor models of the spectrum of \(H_f\).</p>
<p>As well as propagating spectral bounds for factorable functions using M&ouml;nnigmann's technique, <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a> provides support for computing spectral bounds based on the interval Hessian matrix of a twice continuously-differentiable, factorable function using either Gershgorin's circle criterion or Hertz &amp; Rohn's method. As established by Darup <em>et al.</em> [2012], the spectral bound arithmetic may or may not produce tighter spectral bounds than these latter techniques, depending on the factorable function \(f\) at hand and its variable range \(X\).</p>
<p>Results obtained for the factorable function \(f(x,y)=1+x-\sin(2x+3y)-\cos(3x-5y)\) for \(x\in [-0.5,0.5]^2\) are shown in the figure below. This function (red line) and corresponding interval bounds (blue line) are shown in the left plot, while the minimal and maximal eigenvalues (red and green lines) as well as the computed spectral bounds (blue line) of the Hessian matrix \(H_f\) are shown on the right plot.</p>
<center><table  border="0">
<tr>
<td><div class="image">
<img src="SB-2D_function.png" alt="SB-2D_function.png"/>
</div>
 </td><td><div class="image">
<img src="SB-2D_spectral.png" alt="SB-2D_spectral.png"/>
</div>
  </td></tr>
</table>
</center><h2><a class="anchor" id="sec_SPECBND_I"></a>
How do I compute (interval) bounds on the spectrum of the Hessian matrix of a factorable function?</h2>
<p>Suppose we want to compute a spectral (interval) bound for the Hessian matrix of the real-valued function \(f(x_1,x_2,x_3)=\exp(x_1-2x_2^2+3x_3^3)\) for \((x_1,x_2,x_3)\in [-0.3,0.2]\times[-0.1,0.6]\times[-0.4,0.5]\). For simplicity, this bound is calculated using the default interval type, <a class="el" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function.">mc::Interval</a>:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">      #include &quot;interval.hpp&quot;</span>
<span class="preprocessor">      #include &quot;specbnd.hpp&quot;</span>
      <span class="keyword">typedef</span> <a class="code" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function.">mc::Interval</a> I;
      <span class="keyword">typedef</span> <a class="code" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd&lt;I&gt;</a> SB;
</pre></div><p>First, the variables \(x_1\), \(x_2\) and \(x_3\) are defined as follows:</p>
<div class="fragment"><pre class="fragment">      SB X1( I(-0.3,0.2), 0, 3 );
      SB X2( I(-0.1,0.6), 1, 3 );
      SB X3( I(-0.4,0.5), 2, 3 );
</pre></div><p>Essentially, the first line means that <code>X1</code> is a variable of class <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a>, belongs to the interval \([-0.3,0.2]\), and having index 0 out of 3 independent variables (recall that indexing in C/C++ starts at 0 by convention!). The same holds for the <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a> variable <code>X2</code> and <code>X3</code>.</p>
<p>Having defined the variables, spectral bounds on the Hessian matrix \(H_f\) of \(f\) on \([-0.3,0.2]\times[-0.1,0.6]\times[-0.4,0.5]\) are simply calculated as:</p>
<div class="fragment"><pre class="fragment">      SB F = exp( X1 - 2*sqr(X2) + 3*pow(X3,3) );
</pre></div><p>The computed spectral bounds can be retrieved as:</p>
<div class="fragment"><pre class="fragment">      I specF = F.SI();
</pre></div><p>The function and first-derivative bounds can also be retrieved using <a class="el" href="group__SPECBND.html#ga1b3f18a4bba2a1988708da537c53ae54" title="Return function bounds.">mc::Specbnd::I</a> and <a class="el" href="group__SPECBND.html#ga2a62beacd3928e337593c6627cbcc43b" title="Return function and gradient bounds.">mc::Specbnd::FI</a>. The results of the spectral bound propagation can be displayed to the standard output as:</p>
<div class="fragment"><pre class="fragment">      std::cout &lt;&lt; F &lt;&lt; std::endl;
</pre></div><p>which produces the following display: </p>
<div class="fragment"><pre class="fragment">
  [ -1.99039e+01 :  3.70043e+01 ]
  [  2.97601e-01 :  1.77713e+00 ]
  ( [  2.97601e-01 :  1.77713e+00 ] )
  ( [ -4.26511e+00 :  7.10852e-01 ] )
  ( [  0.00000e+00 :  3.99854e+00 ] )
</pre></div><p>Note that the display is organized as follows: </p>
<p class="formulaDsp">
\begin{align*} &amp; [\underline{\lambda}:\overline{\lambda}]\\ &amp; [\underline{f}:\overline{f}]\\ &amp; \left(\begin{array}{l} [\underline{\partial_{x_1}f}:\overline{\partial_{x_1}f}]\\ [\underline{\partial_{x_2}f}:\overline{\partial_{x_2}f}]\\ [\underline{\partial_{x_3}f}:\overline{\partial_{x_3}f}]\end{array}\right) \end{align*}
</p>
<p> That is, the spectral bound is \([-19.904,37.004]\) here.</p>
<p>As noted earlier, other methods are available for bounding the spectrum of interval Hessian matrices, such as Gershgorin's circle criterion and Hertz &amp; Rohn's method. <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a> also provides a means for computing these bounds, e.g. for comparison with the M&ouml;nnigmann's eigenvalue arithmetic. Interval Hessian matrices can be computed using the forward and/or reverse AD types of <a href="http://www.fadbad.com/fadbad.html">FADBAD++</a>:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">      #include &quot;mcfadbad.hpp&quot;</span>
      <span class="keyword">typedef</span> fadbad::F&lt;I&gt; FI;
      <span class="keyword">typedef</span> fadbad::F&lt;FI&gt; FFI;
      <span class="keyword">typedef</span> fadbad::B&lt;FI&gt; BFI;
</pre></div><p>Then, in order to compute spectral bounds for \(f(x_1,x_2,x_3)=\exp(x_1-2x_2^2+3x_3^3)\) on \((x_1,x_2,x_3)\in [-0.3,0.2]\times[-0.1,0.6]\times[-0.4,0.5]\), we proceed as follows:</p>
<div class="fragment"><pre class="fragment">      FI FX1 = I(-0.3,0.2); FX1.diff(0,3);
      FI FX2 = I(-0.1,0.6); FX2.diff(1,3);
      FI FX3 = I(-0.4,0.5); FX3.diff(2,3);

      FFI FFX1 = FX1; FFX1.diff(0,3);
      FFI FFX2 = FX2; FFX2.diff(1,3);
      FFI FFX3 = FX3; FFX3.diff(2,3);
      FFI FFZ = exp( FFX1 - 2*pow(FFX2,2) + 3*pow(FFX3,3) );
      std::pair&lt;double,double&gt; spbndF;
      
      SB::options.HESSBND = SB::Options::GERSHGORIN;
      spbndF = SB::spectral_bound( FFZ );
      std::cout &lt;&lt; <span class="stringliteral">&quot;Spectral bound (Gershgorin, forward-forward): &quot;</span> &lt;&lt; I(spbndF.first,spbndF.second) &lt;&lt; std::endl;

      SB::options.HESSBND = SB::Options::HERTZROHN;
      spbndF = SB::spectral_bound( FFZ );
      std::cout &lt;&lt; <span class="stringliteral">&quot;Spectral bound (Hertz&amp;Rohn, forward-forward): &quot;</span> &lt;&lt; I(spbndF.first,spbndF.second) &lt;&lt; std::endl;
</pre></div><p>producing: </p>
<div class="fragment"><pre class="fragment">
Spectral bound (Gershgorin, forward-forward): [ -2.63904e+01 :  3.85859e+01 ]
Spectral bound (Hertz&amp;Rohn, forward-forward): [ -2.11973e+01 :  3.05272e+01 ]
</pre></div><p>In this case, the eigenvalue arithmetic provides tighter bounds than with Gershgorin's circle criterion, yet looser than with Herz &amp; Rohn's method.</p>
<p>Spectral bounds for interval Hessian matrices generated with the forward-reverse mode of AD can also be computed:</p>
<div class="fragment"><pre class="fragment">      BFI BFX[3] = { FX1, FX2, FX3 };
      BFI BFZ = exp( BFX[0] - 2*pow(BFX[1],2) + 3*pow(BFX[2],3) );
      BFZ.diff(0,1);
      std::pair&lt;double,double&gt; spbndB;

      SB::options.HESSBND = SB::Options::GERSHGORIN;
      spbndB = SB::spectral_bound( BFX );
      std::cout &lt;&lt; <span class="stringliteral">&quot;Spectral bound (Gershgorin, forward-reverse): &quot;</span> &lt;&lt; I(spbndB.first,spbndB.second) &lt;&lt; std::endl;

      SB::options.HESSBND = SB::Options::HERTZROHN;
      spbndB = SB::spectral_bound( BFX );
      std::cout &lt;&lt; <span class="stringliteral">&quot;Spectral bound (Hertz&amp;Rohn, forward-reverse):  &quot;</span> &lt;&lt; I(spbndB.first,spbndB.second) &lt;&lt; std::endl;
</pre></div><p>producing: </p>
<div class="fragment"><pre class="fragment">
Spectral bound (Gershgorin, forward-reverse): [ -2.63904e+01 :  3.85859e+01 ]
Spectral bound (Hertz&amp;Rohn, forward-reverse): [ -2.11973e+01 :  3.05272e+01 ]
</pre></div><p>In this case, the spectral bounds computed from the Hessian matrix obtained with the forward-forward and forward-reverse modes of AD are indeed identical, although such may not always be the case; see [Darup <em>et al.</em>, 2012]</p>
<h2><a class="anchor" id="sec_SPECBND_MC"></a>
How do I compute convex/concave relaxations on the spectrum of the Hessian matrix of a factorable function?</h2>
<p>Instead of using standard interval arithmetic for propagating spectral bounds, we can as well make use of the McCormick relaxation technique to propagate convex/concave bounds. Using MC++, this is done simply by selecting <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> as the template parameter in <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a>:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">      #include &quot;mccormick.hpp&quot;</span>
      <span class="keyword">typedef</span> <a class="code" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick&lt;I&gt;</a> MC;
      <span class="keyword">typedef</span> <a class="code" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd&lt;MC&gt;</a> SBMC;
</pre></div><p>Then, the procedure for computing a spectral bound remains essentially the same as described in the previous section. In order to compute convex/concave spectral relaxations and subgradients at point \((0,0,0)\) of \(f(x_1,x_2,x_3)=\exp(x_1-2x_2^2+3x_3^3)\) for \((x_1,x_2,x_3)\in [-0.3,0.2]\times[-0.1,0.6]\times[-0.4,0.5]\), we proceed as follows:</p>
<div class="fragment"><pre class="fragment">      SBMC X1( MC(I(-0.3,0.2),0.).sub(3,0), 0, 3 );
      SBMC X2( MC(I(-0.1,0.6),0.).sub(3,1), 1, 3 );
      SBMC X3( MC(I(-0.4,0.5),0.).sub(3,2), 2, 3 );
      SBMC F = exp( X1 - 2*sqr(X2) + 3*pow(X3,3) );
      MC specF = F.SI();
      std::cout &lt;&lt; F &lt;&lt; std::endl;
</pre></div><p>The only difference here concerns the initialization of the McCormick variables inside the variables X and Y, which passes the bounds for the variable as well as the point at which the convex/concave bounds and their subgradients are computed&mdash;See How do I compute McCormick relaxations of a factorable function?</p>
<p>More information on the spectral relaxations can again be obtained as:</p>
<div class="fragment"><pre class="fragment">      std::cout &lt;&lt; F &lt;&lt; std::endl;
</pre></div><p>which displays: </p>
<div class="fragment"><pre class="fragment">
  [ -1.99039e+01 :  3.70043e+01 ] [ -1.54413e+01 :  2.81720e+01 ] [ (-9.27293e+00, 0.00000e+00,-5.21602e+00) : ( 1.72398e+01, 0.00000e+00, 1.50542e+01) ]
  [  2.97601e-01 :  1.77713e+00 ] [  8.45354e-01 :  1.37868e+00 ] [ ( 8.45354e-01,-8.45354e-01, 3.04327e-01) : ( 8.27940e-01, 0.00000e+00, 4.65716e-01) ]
  ( [  2.97601e-01 :  1.77713e+00 ] [  8.45354e-01 :  1.37868e+00 ] [ ( 8.45354e-01,-8.45354e-01, 3.04327e-01) : ( 8.27940e-01, 0.00000e+00, 4.65716e-01) ] )
  ( [ -4.26511e+00 :  7.10852e-01 ] [ -3.72711e-01 :  4.32433e-01 ] [ ( 3.38142e-01,-7.44666e+00, 1.21731e-01) : ( 3.31176e-01,-1.19041e+00, 1.86287e-01) ] )
  ( [  0.00000e+00 :  3.99854e+00 ] [  0.00000e+00 :  2.96812e+00 ] [ ( 0.00000e+00, 0.00000e+00, 0.00000e+00) : ( 1.86287e+00, 0.00000e+00, 1.31570e+00) ] )
</pre></div><p>By construction, the underlying interval bounds of the McCormick relaxations are identical to their spectral interval bound counterparts. The convex/concave bounds at \((0,0,0)\) come as additional information and are seen to be tighter than the interval bounds. The corresponding subgradients can also be used to construct affine relaxations.</p>
<p>Similarly, a Taylor model of the spectrum can be conveniently computed by selecting <a class="el" href="classmc_1_1TVar.html" title="C++ class for Taylor model computation of factorable function - Taylor model propagation.">mc::TVar</a> as the template parameter in <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a>.</p>
<h2><a class="anchor" id="sec_SPECBND_fct"></a>
Which functions are overloaded in mc::Specbnd eigenvalue arithmetic?</h2>
<p><a class="el" href="classmc_1_1TVar.html" title="C++ class for Taylor model computation of factorable function - Taylor model propagation.">mc::TVar</a> overloads the usual functions <code>exp</code>, <code>log</code>, <code>sqr</code>, <code>sqrt</code>, <code>pow</code>, <code>inv</code>, <code>cos</code>, <code>sin</code>, <code>tan</code>, <code>acos</code>, <code>asin</code>, <code>atan</code>. Unlike <a class="el" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function.">mc::Interval</a> and <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a>, the functions <code>min</code>, <code>max</code> and <code>fabs</code> are not overloaded in <a class="el" href="classmc_1_1TVar.html" title="C++ class for Taylor model computation of factorable function - Taylor model propagation.">mc::TVar</a> since they are not twice continuously differentiable. Also, <code>erf</code> and <code>erfc</code> are overloaded in <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a> but currently cannot be used due to a limitation in the third-party libarary <a href="http://www.fadbad.com/fadbad.html">FADBAD++</a>, where these functions are not (yet?) overloaded.</p>
<h2><a class="anchor" id="sec_SPECBND_fadbad"></a>
How do I compute spectral bounds of the partial derivatives or the Taylor coefficients of a factorable function using FADBAD++?</h2>
<p>The combination of <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a> with the classes fadbad::F, and fadbad::B of <a href="http://www.fadbad.com/fadbad.html">FADBAD++</a> to compute a spectral bound for the Hessian matrix of either the partial derivatives or the Taylor coefficients of a factorable function is essentially the same as with <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> (see <a class="el" href="page_MCCORMICK.html#sec_MCCORMICK_fadbad">How do I compute McCormick relaxations of the partial derivatives or the Taylor coefficients of a factorable function using FADBAD++?</a>) or <a class="el" href="classmc_1_1TVar.html" title="C++ class for Taylor model computation of factorable function - Taylor model propagation.">mc::TVar</a> (see <a class="el" href="page_TAYLOR.html#sec_TAYLOR_fadbad">How do I compute Taylor models of the partial derivatives or the Taylor coefficients of a factorable function using FADBAD++?</a>).</p>
<p>Next, we present the case of fadbad::F only. Continuing the previous example, spectral bounds of the partial derivatvies of \(f(x_1,x_2,x_3)=\exp(x_1-2x_2^2+3x_3^3)\) for \((x_1,x_2,x_3)\in [-0.3,0.2]\times[-0.1,0.6]\times[-0.4,0.5]\) can be computed as follows:</p>
<div class="fragment"><pre class="fragment">      <span class="keyword">typedef</span> fadbad::F&lt;SB&gt; FSB;
</pre></div><div class="fragment"><pre class="fragment">      FSB FSBX1 = X1; FSBX1.diff(0,3);
      FSB FSBX2 = X2; FSBX2.diff(1,3);
      FSB FSBX3 = X3; FSBX3.diff(2,3);
      FSB FSBF = exp( FSBX1 - 2*pow(FSBX2,2) + 3*pow(FSBX3,3) );
      std::cout &lt;&lt; <span class="stringliteral">&quot;Spectral bounds of df/dx1:\n&quot;</span> &lt;&lt; FSBF.d(0) &lt;&lt; std::endl;
      std::cout &lt;&lt; <span class="stringliteral">&quot;Spectral bounds of df/dx2:\n&quot;</span> &lt;&lt; FSBF.d(1) &lt;&lt; std::endl;
      std::cout &lt;&lt; <span class="stringliteral">&quot;Spectral bounds of df/dx3:\n&quot;</span> &lt;&lt; FSBF.d(2) &lt;&lt; std::endl;
</pre></div><p>producing the output:</p>
<div class="fragment"><pre class="fragment">
Spectral bounds of df/dx1:
  [ -1.99039e+01 :  3.70043e+01 ]
  [  2.97601e-01 :  1.77713e+00 ]
  ( [  2.97601e-01 :  1.77713e+00 ] )
  ( [ -4.26511e+00 :  7.10852e-01 ] )
  ( [  0.00000e+00 :  3.99854e+00 ] )

Spectral bounds of df/dx2:
  [ -1.16096e+02 :  8.92716e+01 ]
  [ -4.26511e+00 :  7.10852e-01 ]
  ( [ -4.26511e+00 :  7.10852e-01 ] )
  ( [ -8.81457e+00 :  9.04587e+00 ] )
  ( [ -9.59650e+00 :  1.59942e+00 ] )

Spectral bounds of df/dx3:
  [ -1.28567e+02 :  2.06229e+02 ]
  [  0.00000e+00 :  3.99854e+00 ]
  ( [  0.00000e+00 :  3.99854e+00 ] )
  ( [ -9.59650e+00 :  1.59942e+00 ] )
  ( [ -1.27953e+01 :  2.49909e+01 ] )
</pre></div><h2><a class="anchor" id="sec_SPECBND_opt"></a>
How are the options set for the computation of a spectral bound?</h2>
<p>The class <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a> has a public static member called mc::Specbnd::options that can be used to set/modify the options; e.g.,</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd&lt;I&gt;::options</a>.HESSBND = <a class="code" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd&lt;I&gt;::Options::HERTZROHN</a>;
</pre></div><p>The available options are the following:</p>
<table  border="1">
<caption align="bottom"><em>Options in <a class="el" href="structmc_1_1Specbnd_1_1Options.html" title="Options of mc::Specbnd.">mc::Specbnd::Options</a>: name, type and description</em></caption>
<tr>
<th><b>Name</b> </th><td><b>Type</b></td><td><b>Default</b> </td><td><b>Description</b> </td></tr>
<tr>
<th><code>HESSBND</code> </th><td><code><a class="el" href="structmc_1_1Specbnd_1_1Options.html#a8017101584991be06de38e3003418db3" title="Strategy for computing spectral bounds in interval Hessian matrix.">mc::Specbnd::Options::HESSBND_STRATEGY</a></code> </td><td><a class="el" href="structmc_1_1Specbnd_1_1Options.html#a8017101584991be06de38e3003418db3ab96d1b2fea5ae226df68de29f48fff6f" title="Gershgorin circle&#39;s criterion.">mc::Specbnd::Options::GERSHGORIN</a> </td><td>Strategy for computing spectral bounds in interval Hessian matrix using <a class="el" href="group__SPECBND.html#ga3c8da995fb9e0550161781b26266dafd" title="Compute spectral bound of interval Hessian matrix D2X of type fadbad::B&lt; fadbad::F&lt;T&gt; &gt;*...">mc::Specbnd::spectral_bound</a> </td></tr>
</table>
<h2><a class="anchor" id="sec_SPECBND_err"></a>
Errors What errors can I encounter during computation of a spectral bound?</h2>
<p>Errors are managed based on the exception handling mechanism of the C++ language. Each time an error is encountered, a class object of type <a class="el" href="classmc_1_1Specbnd_1_1Exceptions.html" title="Exceptions of mc::Specbnd.">mc::Specbnd::Exceptions</a> is thrown, which contains the type of error. It is the user's responsibility to test whether an exception was thrown during the computation of a spectral bound, and then make the appropriate changes. Should an exception be thrown and not caught by the calling program, the execution will abort.</p>
<p>Possible errors encountered during the computation of a spectral bound are:</p>
<table  border="1">
<caption align="bottom"><em>Errors during the Computation of a Spectral Bound</em></caption>
<tr>
<th><b>Number</b> </th><td><b>Description</b> </td></tr>
<tr>
<th><code>1</code> </th><td>Failed to compute spectrum in Specbnd::spectrum </td></tr>
<tr>
<th><code>2</code> </th><td>Failed to compute spectral bound in Specbnd::spectral_bound </td></tr>
<tr>
<th><code>-1</code> </th><td>Operation between variables with different numbers of dependents </td></tr>
<tr>
<th><code>-33</code> </th><td>Feature not yet implemented in <a class="el" href="classmc_1_1Specbnd.html" title="C++ template class computing spectral bounds for the Hessian matrix of a factorable function on a box...">mc::Specbnd</a> </td></tr>
</table>
<p>Moreover, exceptions may be thrown by the template parameter class itself.</p>
<h2><a class="anchor" id="sec_SPECBND_refs"></a>
References</h2>
<ul>
<li>Adjiman, C.S., S. Dallwig, C.A. Floudas, and A. Neumaier, <a href="http://dx.doi.org/10.1016/S0098-1354(98)00027-1">A global optimization method, \(\rm\alpha BB\), for general twice-differentiable constrained NLPs-I. Theoretical advances</a>, <em>Computers &amp; Chemical Engineering</em> <b>22</b>(9):1137-1158, 1998.</li>
<li>Hertz, D., <a href="http://dx.doi.org/10.1109/9.126593">The extreme eigenvalues and stability of real symmetric interval matrices</a>, <em>IEEE Transactions on Automatic Control</em> <b>37</b>:532-535, 1992.</li>
<li>M&ouml;nnigmann, M., <a href="http://dx.doi.org/10.1137/070704186">Efficient calculation of bounds on spectra of Hessian matrices</a>, <em>SIAM Journal on Scientific Computing</em>, <b>30</b>:2340-2357, 2008.</li>
<li>M&ouml;nnigmann, M., <a href="http://dx.doi.org/10.1137/10078760X">Fast Calculation of Spectral Bounds for Hessian Matrices on Hyperrectangles</a>, <em>SIAM Journal on Matrix Analysis and Applications</em>, <b>32</b>:4, 1351-1366, 2011.</li>
<li>Darup, M. S., M. Kastsian, S. Mross, and M. M&ouml;nnigmann, <a href="http://arxiv.org/pdf/1206.0196.pdf">Efficient Computation of Spectral Bounds for Hessian Matrices on Hyperrectangles for Global Optimization</a>, arXiv:1206.0196v1, 1 June 2012.</li>
</ul>
</div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Thu Jul 25 2013 13:28:41 for MC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
