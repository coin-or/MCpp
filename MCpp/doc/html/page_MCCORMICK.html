<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MC++: McCormick Relaxation Arithmetic for Factorable Functions</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://www.mathjax.org/mathjax/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MC++
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('page_MCCORMICK.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">McCormick Relaxation Arithmetic for Factorable Functions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="author"><dt><b>Author:</b></dt><dd>Beno&icirc;t Chachuat</dd></dl>
<p>A convex relaxation \(f^{\rm cv}\) of a function \(f\) on the convex domain \(D\) is a function that is (i) convex on \(D\) and (ii) underestimates \(f\) on \(D\). Likewise, a concave relaxation \(f^{\rm cc}\) of a function \(f\) on the convex domain \(D\) is a function that is (i) concave on \(D\) and (ii) overestimates \(f\) on \(D\). McCormick's technique [McCormick, 1976] provides a means for computing pairs of convex/concave relaxations of a multivariate function on interval domains provided that this function is factorable and that the intrinsic univariate functions in its factored form have known convex/concave envelopes or, at least, relaxations.</p>
<center><table  border="0">
<tr>
<td><div class="image">
<img src="McCormick_relax.png" alt="McCormick_relax.png"/>
</div>
  </td></tr>
</table>
</center><p>The class <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> provides an implementation of the McCormick relaxation technique and its recent extensions; see [McCormick, 1976; Scott <em>et al.</em>, 2011; Tsoukalas &amp; Mitsos, 2012; Wechsung &amp; Barton, 2013]. <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> also has the capability to propagate subgradients for these relaxations, which are guaranteed to exist in the interior of the domain of definition of any convex/concave function. This propagation is similar in essence to the forward mode of automatic differentiation; see [Mitsos <em>et al.</em>, 2009]. We note that <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> is <b>not a verified implementation</b> in the sense that rounding errors are not accounted for in computing convex/concave bounds and subgradients.</p>
<p>The implementation of <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> relies on the operator/function overloading mechanism of C++. This makes the computation of convex/concave relaxations both simple and intuitive, similar to computing function values in real arithmetics or function bounds in interval arithmetic (see <a class="el" href="page_INTERVAL.html">Non-Verified Interval Arithmetic for Factorable Functions</a>). Moreover, <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> can be used as the template parameter of other classes of MC++, for instance <a class="el" href="classmc_1_1TModel.html" title="C++ class for Taylor model computation of factorable function - Taylor model environment.">mc::TModel</a> and <a class="el" href="classmc_1_1TVar.html" title="C++ class for Taylor model computation of factorable function - Taylor model propagation.">mc::TVar</a>. Likewise, <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> can be used as the template parameter of the classes fadbad::F, fadbad::B and fadbad::T of <a href="http://www.fadbad.com/fadbad.html">FADBAD++</a> for computing McCormick relaxations and subgradients of the partial derivatives or the Taylor coefficients of a factorable function (see <a class="el" href="page_MCCORMICK.html#sec_MCCORMICK_fadbad">How do I compute McCormick relaxations of the partial derivatives or the Taylor coefficients of a factorable function using FADBAD++?</a>).</p>
<p><a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> itself is templated in the type used to propagate the supporting interval bounds. By default, <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> can be used with the non-verified interval type <a class="el" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function.">mc::Interval</a> of MC++. For reliability, however, it is strongly recommended to use verified interval arithmetic such as <a href="http://www.ti3.tu-harburg.de/Software/PROFILEnglisch.html">PROFIL</a> or <a href="http://www.math.uni-wuppertal.de/~xsc/software/filib.html">FILIB++</a>. We note that Taylor models as provided by the classes <a class="el" href="classmc_1_1TModel.html" title="C++ class for Taylor model computation of factorable function - Taylor model environment.">mc::TModel</a> and <a class="el" href="classmc_1_1TVar.html" title="C++ class for Taylor model computation of factorable function - Taylor model propagation.">mc::TVar</a> can also be used as the template parameter (see <a class="el" href="page_TAYLOR.html">Taylor Model Arithmetic for Factorable Functions</a>).</p>
<p>Examples of McCormick relaxations constructed with <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> are shown on the left plot of the figure below for the factorable function \(f(x)=\cos(x^2)\,\sin(x^{-3})\) for \(x\in [\frac{\pi}{6},\frac{\pi}{3}]\). Also shown on the right plot are the affine relaxations constructed from a subgradient at \(\frac{\pi}{4}\) of the McCormick relaxations of \(f\) on \([\frac{\pi}{6},\frac{\pi}{3}]\).</p>
<center><table  border="0">
<tr>
<td><div class="image">
<img src="MC-1D_relax.png" alt="MC-1D_relax.png"/>
</div>
 </td><td><div class="image">
<img src="MC-1D_linearize.png" alt="MC-1D_linearize.png"/>
</div>
  </td></tr>
</table>
</center><h2><a class="anchor" id="sec_MCCORMICK_use"></a>
How do I compute McCormick relaxations of a factorable function?</h2>
<p>Suppose one wants to compute McCormick relaxation of the real-valued function \(f(x,y)=x(\exp(x)-y)^2\) for \((x,y)\in [-2,1]\times[-1,2]\), at the point \((x,y)=(0,1)\). For simplicity, the supporting interval bounds are calculated using the default interval type <a class="el" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function.">mc::Interval</a> here:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">      #include &quot;interval.hpp&quot;</span>
      <span class="keyword">typedef</span> <a class="code" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function.">mc::Interval</a> I;
      <span class="keyword">typedef</span> <a class="code" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick&lt;I&gt;</a> MC;
</pre></div><p>First, the variables \(x\) and \(y\) are defined as follows:</p>
<div class="fragment"><pre class="fragment">      MC X( I( -2., 1. ), 0. );
      MC Y( I( -1., 2. ), 1. );
</pre></div><p>Essentially, the first line means that <code>X</code> is a variable of type <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a>, belonging to the interval \([-2,1]\), and whose current value is \(0\). The same holds for the McCormick variable <code>Y</code>, which belonging to the interval \([-1,2]\) and has a value of \(1\).</p>
<p>Having defined the variables, McCormick relaxations of \(f(x,y)=x(\exp(x)-y)^2\) on \([-2,1]\times[-1,2]\) at \((0,1)\) are simply computed as:</p>
<div class="fragment"><pre class="fragment">      MC F = X*pow(exp(X)-Y,2);
</pre></div><p>These relaxations can be displayed to the standard output as:</p>
<div class="fragment"><pre class="fragment">      std::cout &lt;&lt; <span class="stringliteral">&quot;f relaxations at (0,1): &quot;</span> &lt;&lt; F &lt;&lt; std::endl;
</pre></div><p>which produces the following output:</p>
<div class="fragment"><pre class="fragment">
f relaxations at (0,1): [ -2.76512e+01 :  1.38256e+01 ] [ -1.38256e+01 :  8.52245e+00 ]
</pre></div><p>Here, the first pair of bounds correspond to the supporting interval bounds, as obtained with <a class="el" href="classmc_1_1Interval.html" title="C++ class for (non-verified) interval bounding of factorable function.">mc::Interval</a>, and which are valid over the entire domain \([-2,1]\times[-1,2]\). The second pair of bounds are the values of the convex and concave relaxations at the selected point \((0,1)\). In order to describe the convex and concave relaxations on the entire range \([-2,1]\times[-1,2]\), it would be necessary to repeat the computations at different points. The current point can be set/modified by using the method <a class="el" href="group__MCCORMICK.html#ga4161a03848d77156f3887fb1462cbb37" title="Set both convex and concave bounds to c">mc::McCormick::c</a>, for instance at \((-1,0)\)</p>
<div class="fragment"><pre class="fragment">      X.c( -1. );
      Y.c( 0. );
      F = X*pow(exp(X)-Y,2);
      std::cout &lt;&lt; <span class="stringliteral">&quot;f relaxations at (-1,0): &quot;</span> &lt;&lt; F &lt;&lt; std::endl;
</pre></div><p>producing the output:</p>
<div class="fragment"><pre class="fragment">
f relaxations at (-1,0): [ -2.76512e+01 :  1.38256e+01 ] [ -1.75603e+01 :  8.78014e+00 ]
</pre></div><p>The values of the McCormick convex and concave relaxations of \(f(x,y)\) can be retrieved, respectively, as:</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">double</span> Fcv = F.cv();
      <span class="keywordtype">double</span> Fcc = F.cc();
</pre></div><p>Likewise, the lower and upper bounds of the supporting interval bounds can be retrieved as:</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">double</span> Flb = F.l();
      <span class="keywordtype">double</span> Fub = F.u();
</pre></div><h2><a class="anchor" id="sec_MCCORMICK_sub"></a>
How do I compute a subgradient of the McCormick relaxations?</h2>
<p>Computing a subgradient of a McCormick relaxation requires specification of the independent variables via the .sub method, prior to evaluating the function in <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> type. Continuing the previous example, the function has two independent variables \(x\) and \(y\). Defining \(x\) and \(y\) as the subgradient components \(0\) and \(1\) (indexing in C/C++ start at 0 by convention!), respectively, is done as follows:</p>
<div class="fragment"><pre class="fragment">      X.sub( 2, 0 );
      Y.sub( 2, 1 );
</pre></div><p>Similar to above, the McCormick convex and concave relaxations of \(f(x,y)\) at \((-1,0)\) along with subgradients of these relaxations are computed as:</p>
<div class="fragment"><pre class="fragment">      F = X*pow(exp(X)-Y,2);
      std::cout &lt;&lt; <span class="stringliteral">&quot;f relaxations and subgradients at (-1,0): &quot;</span> &lt;&lt; F &lt;&lt; std::endl;
</pre></div><p>producing the output:</p>
<div class="fragment"><pre class="fragment">
f relaxations and subgradients at (-1,0): [ -2.76512e+01 :  1.38256e+01 ] [ -1.75603e+01 :  8.78014e+00 ] [ (-3.19186e+00, 3.70723e+00) : ( 1.59593e+00,-1.85362e+00) ]
</pre></div><p>The additional information displayed corresponds to, respectively, a subgradient of the McCormick convex underestimator at (-1,0) and a subgradient of the McCormick concave overestimator at (-1,0). In turn, these subgradients can be used to construct affine relaxations on the current range, or passed to a bundle solver to locate the actual minimum or maximum of the McCormick relaxations.</p>
<p>The subgradients of the McCormick relaxations of \(f(x,y)\) at the current point can be retrieved as follows:</p>
<div class="fragment"><pre class="fragment">      <span class="keyword">const</span> <span class="keywordtype">double</span>* Fcvsub = F.cvsub();
      <span class="keyword">const</span> <span class="keywordtype">double</span>* Fccsub = F.ccsub();
</pre></div><p>or, alternatively, componentwise as:</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">double</span> Fcvsub_X = F.cvsub(0);
      <span class="keywordtype">double</span> Fcvsub_Y = F.cvsub(1);
      <span class="keywordtype">double</span> Fccsub_X = F.ccsub(0);
      <span class="keywordtype">double</span> Fccsub_Y = F.ccsub(1);
</pre></div><p>Directional subgradients can be propagated too. In the case that subgradients are to computed along the direction (1,-1) for both the convex and concave relaxations, we define:</p>
<div class="fragment"><pre class="fragment">      <span class="keyword">const</span> <span class="keywordtype">double</span> sub_dir[2] = { 1., -1 };
      X.sub( 1, &amp;sub_dir[0], &amp;sub_dir[0] );
      Y.sub( 1, &amp;sub_dir[1], &amp;sub_dir[1] );
      F = X*pow(exp(X)-Y,2);
      std::cout &lt;&lt; <span class="stringliteral">&quot;f relaxations and subgradients along direction (1,-1) at (-1,0): &quot;</span> &lt;&lt; F &lt;&lt; std::endl;
</pre></div><p>producing the output:</p>
<div class="fragment"><pre class="fragment">
f relaxations and subgradients along direction (1,-1) at (-1,0): [ -2.76512e+01 :  1.38256e+01 ] [ -1.75603e+01 :  8.78014e+00 ] [ (-6.89910e+00) : ( 3.44955e+00) ]
</pre></div><h2><a class="anchor" id="sec_MCCORMICK_fadbad"></a>
How do I compute McCormick relaxations of the partial derivatives or the Taylor coefficients of a factorable function using FADBAD++?</h2>
<p>Now suppose one wants to compute McCormick relaxation not only for a given factorable function, but also for its partial derivatives. Continuing the previous example, the partial derivatives of \(f(x,y)=x(\exp(x)-y)^2\) with respect to its independent variables \(x\) and \(y\) can be obtained via automatic differentiation (AD), either forward or reverse AD. This can be done for instance using the classes fadbad::F, and fadbad::B of <a href="http://www.fadbad.com/fadbad.html">FADBAD++</a>.</p>
<p>Considering forward AD first, we include the following header files:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">      #include &quot;mcfadbad.hpp&quot;</span> <span class="comment">// available in MC++</span>
<span class="preprocessor">      #include &quot;fadiff.h&quot;</span>     <span class="comment">// available in FADBAD++</span>
      <span class="keyword">typedef</span> fadbad::F&lt;MC&gt; FMC;
</pre></div><p>The variables are initialized and the derivatives and subgradients are seeded as follows:</p>
<div class="fragment"><pre class="fragment">      FMC FX = X;             <span class="comment">// initialize FX with McCormick variable X</span>
      FX.diff(0,2);           <span class="comment">// differentiate with respect to x (index 0 of 2)</span>
      FX.x().sub(2,0);        <span class="comment">// seed subgradient of x (index 0 of 2)</span>

      FMC FY = Y;             <span class="comment">// initialize FY with McCormick variable Y</span>
      FY.diff(1,2);           <span class="comment">// differentiate with respect to y (index 1 of 2)</span>
      FY.x().sub(2,1);        <span class="comment">// seed subgradient of y (index 1 of 2)</span>
</pre></div><p>As previously, the McCormick convex and concave relaxations of \(f\), \(\frac{\partial f}{\partial x}\), and \(\frac{\partial f}{\partial y}\) at \((-1,0)\) on the range \([-2,1]\times[-1,2]\), along with subgradients of these relaxations, are computed as:</p>
<div class="fragment"><pre class="fragment">      FMC FF = FX*pow(exp(FX)-FY,2);
      std::cout &lt;&lt; <span class="stringliteral">&quot;f relaxations and subgradients at (-1,0): &quot;</span> &lt;&lt; FF.x() &lt;&lt; std::endl;
      std::cout &lt;&lt; <span class="stringliteral">&quot;df/dx relaxations and subgradients at (-1,0): &quot;</span> &lt;&lt; FF.d(0) &lt;&lt; std::endl;
      std::cout &lt;&lt; <span class="stringliteral">&quot;df/dy relaxations and subgradients at (-1,0): &quot;</span> &lt;&lt; FF.d(1) &lt;&lt; std::endl;
</pre></div><p>producing the output:</p>
<div class="fragment"><pre class="fragment">
f relaxations and subgradients at (-1,0): [ -2.76512e+01 :  1.38256e+01 ] [ -1.75603e+01 :  8.78014e+00 ] [ (-3.19186e+00, 3.70723e+00) : ( 1.59593e+00,-1.85362e+00) ]
df/dx relaxations and subgradients at (-1,0): [ -4.04294e+01 :  3.41004e+01 ] [ -2.33469e+01 :  2.90549e+01 ] [ (-2.31383e+01,-1.94418e-01) : ( 1.59593e+00,-1.85362e+00) ]
df/dy relaxations and subgradients at (-1,0): [ -7.45866e+00 :  1.48731e+01 ] [ -5.96505e+00 :  7.71460e+00 ] [ (-5.96505e+00,-4.00000e+00) : ( 7.17326e+00,-4.00000e+00) ]
</pre></div><p>Relaxations of the partial derivatives can also be computed using the backward mode of AD, which requires the additional header file:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">      #include &quot;badiff.h&quot;</span>     <span class="comment">// available in FADBAD++</span>
      <span class="keyword">typedef</span> fadbad::B&lt;MC&gt; BMC;
</pre></div><p>then initialize and seed new variables and compute the function as follows:</p>
<div class="fragment"><pre class="fragment">      BMC BX = X;             <span class="comment">// initialize FX with McCormick variable X</span>
      BX.x().sub(2,0);        <span class="comment">// seed subgradient as direction (1,0)</span>
      BMC BY = Y;             <span class="comment">// initialize FY with McCormick variable Y</span>
      BY.x().sub(2,1);        <span class="comment">// seed subgradient as direction (1,0)</span>

      BMC BF = BX*pow(exp(BX)-BY,2);
      BF.diff(0,1);           <span class="comment">// differentiate f (index 0 of 1)</span>
      std::cout &lt;&lt; <span class="stringliteral">&quot;f relaxations and subgradients at (-1,0): &quot;</span> &lt;&lt; BF.x() &lt;&lt; std::endl;
      std::cout &lt;&lt; <span class="stringliteral">&quot;df/dx relaxations and subgradients at (-1,0): &quot;</span> &lt;&lt; BX.d(0) &lt;&lt; std::endl;
      std::cout &lt;&lt; <span class="stringliteral">&quot;df/dy relaxations and subgradients at (-1,0): &quot;</span> &lt;&lt; BY.d(0) &lt;&lt; std::endl;
</pre></div><p>producing the output:</p>
<div class="fragment"><pre class="fragment">
f relaxations and subgradients at (-1,0): [ -2.76512e+01 :  1.38256e+01 ] [ -1.75603e+01 :  8.78014e+00 ] [ (-3.19186e+00, 3.70723e+00) : ( 1.59593e+00,-1.85362e+00) ]
df/dx relaxations and subgradients at (-1,0): [ -4.04294e+01 :  3.41004e+01 ] [ -1.37142e+01 :  1.60092e+01 ] [ (-1.35056e+01,-1.94418e-01) : ( 8.82498e+00,-1.31228e+00) ]
df/dy relaxations and subgradients at (-1,0): [ -7.45866e+00 :  1.48731e+01 ] [ -5.96505e+00 :  7.71460e+00 ] [ (-5.96505e+00,-4.00000e+00) : ( 7.17326e+00,-4.00000e+00) ]
</pre></div><p>It is noteworthy that the bounds, McCormick relaxations and subgradients for the partial derivatives as computed with the forward and backward mode, although valid, may not be the same since the computations involve different sequences or even operations. In the previous examples, for instance, forward and backward AD produce identical interval bounds for \(\frac{\partial f}{\partial x}\) and \(\frac{\partial f}{\partial y}\) at \((-1,0)\), yet significantly tighter McCormick relaxations are obtained with backward AD for \(\frac{\partial f}{\partial x}\) at \((-1,0)\).</p>
<p>Another use of <a href="http://www.fadbad.com/fadbad.html">FADBAD++</a> involves computing McCormick relaxations of the Taylor coefficients in the Taylor expansion of a factorable function in a given direction up to a certain order. Suppose we want to compute McCormick relaxation of the first 5 Taylor coefficients of \(f(x,y)=x(\exp(x)-y)^2\) in the direction \((1,0)\), i.e. the direction of \(x\). This information can be computed by using the classes fadbad::T, which requires the following header file:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">      #include &quot;tadiff.h&quot;</span>     <span class="comment">// available in FADBAD++</span>
      <span class="keyword">typedef</span> fadbad::T&lt;MC&gt; TMC;
</pre></div><p>The variables are initialized and the derivatives and subgradients are seeded as follows:</p>
<div class="fragment"><pre class="fragment">      TMC TX = X;             <span class="comment">// initialize FX with McCormick variable X</span>
      TX[0].sub(2,0);        <span class="comment">// seed subgradient as direction (1,0)</span>
      TMC TY = Y;             <span class="comment">// initialize FY with McCormick variable Y</span>
      TY[0].sub(2,1);        <span class="comment">// seed subgradient as direction (1,0)</span>
      TX[1] = 1.;             <span class="comment">// Taylor-expand with respect to x</span>

      TMC TF = TX*pow(exp(TX)-TY,2);
      TF.eval(5);            <span class="comment">// Taylor-expand f to degree 5</span>
      <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;=5; i++ )
        std::cout &lt;&lt; <span class="stringliteral">&quot;d^&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;f/dx^&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; relaxations and subgradients at (-1,0): &quot;</span> &lt;&lt; TF[i] &lt;&lt; std::endl;
</pre></div><p>producing the output:</p>
<div class="fragment"><pre class="fragment">
d^0f/dx^0 relaxations and subgradients at (-1,0): [ -2.76512e+01 :  1.38256e+01 ] [ -1.75603e+01 :  8.78014e+00 ] [ (-3.19186e+00, 3.70723e+00) : ( 1.59593e+00,-1.85362e+00) ]
d^1f/dx^1 relaxations and subgradients at (-1,0): [ -4.04294e+01 :  3.41004e+01 ] [ -2.33469e+01 :  2.90549e+01 ] [ (-2.31383e+01,-1.94418e-01) : ( 1.59593e+00,-1.85362e+00) ]
d^2f/dx^2 relaxations and subgradients at (-1,0): [ -4.51302e+01 :  3.77111e+01 ] [ -1.97846e+01 :  2.25846e+01 ] [ (-1.97113e+01, 0.00000e+00) : ( 7.36023e+00,-4.06006e-01) ]
d^3f/dx^3 relaxations and subgradients at (-1,0): [ -2.65667e+01 :  2.82546e+01 ] [ -1.02662e+01 :  1.27412e+01 ] [ (-1.00820e+01,-4.51118e-02) : ( 7.66644e+00,-1.80447e-01) ]
d^4f/dx^4 relaxations and subgradients at (-1,0): [ -1.19764e+01 :  1.59107e+01 ] [ -4.29280e+00 :  6.13261e+00 ] [ (-4.25007e+00,-2.25559e-02) : ( 4.86086e+00,-5.63897e-02) ]
d^5f/dx^5 relaxations and subgradients at (-1,0): [ -4.44315e+00 :  7.16828e+00 ] [ -1.49744e+00 :  2.55611e+00 ] [ (-1.44773e+00,-6.76676e-03) : ( 2.29932e+00,-1.35335e-02) ]
</pre></div><p>The zeroth Taylor coefficient corresponds to the function \(f\) itself. It can also be checked that the relaxations of the first Taylor coefficient of \(f\) matches those obtained with forward AD for \(\frac{\partial f}{\partial x}\).</p>
<p>Naturally, the classes fadbad::F, fadbad::B and fadbad::T can be nested to produce relaxations of higher-order derivative information.</p>
<h2><a class="anchor" id="sec_MCCORMICK_fct"></a>
Which functions are overloaded in McCormick relaxation arithmetic?</h2>
<p>As well as overloading the usual functions <code>exp</code>, <code>log</code>, <code>sqr</code>, <code>sqrt</code>, <code>pow</code>, <code>inv</code>, <code>cos</code>, <code>sin</code>, <code>tan</code>, <code>acos</code>, <code>asin</code>, <code>atan</code>, <code>erf</code>, <code>erfc</code>, <code>min</code>, <code>max</code>, <code>fabs</code>, <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> also defines the following functions:</p>
<ul>
<li><code>fstep(x)</code> and <code>bstep(x)</code>, implementing the forward step function (switching value from 0 to 1 for x&gt;=0) and the backward step function (switching value from 1 to 0 for x&gt;=0). These functions can be used to model a variety of discontinuous functions as first proposed in [Wechsung &amp; Barton, 2012].</li>
<li><code>ltcond(x,y,z)</code> and <code>gtcond(x,y,z)</code>, similar in essence to <code>fstep(x)</code> and <code>bstep(x)</code>, and implementing disjunctions of the form { y if x&lt;=0; z otherwise } and { y if x&gt;=0; z otherwise }, respectively.</li>
<li><code>inter(x,y,z)</code>, computing the intersection \(x = y\cap z\) and returning true/false if the intersection is nonempty/empty.</li>
<li><code>hull(x,y)</code>, computing convex/concave relaxations of the union \(x\cup y\).</li>
</ul>
<h2><a class="anchor" id="sec_MCCORMICK_opt"></a>
What are the options in mc::McCormick and how are they set?</h2>
<p>The class <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> has a public static member called mc::McCormick::options that can be used to set/modify the options; e.g.,</p>
<div class="fragment"><pre class="fragment">      MC::options.ENVEL_USE = <span class="keyword">true</span>;
      MC::options.ENVEL_TOL = 1e-12;
      MC::options.ENVEL_MAXIT = 100;
      MC::options.MVCOMP_USE = <span class="keyword">true</span>;
</pre></div><p>The available options are the following:</p>
<table  border="1">
<caption align="bottom"><em>Options in <a class="el" href="structmc_1_1McCormick_1_1Options.html" title="Options of mc::McCormick.">mc::McCormick::Options</a>: name, type and description</em></caption>
<tr>
<th><b>Name</b> </th><td><b>Type</b></td><td><b>Default</b> </td><td><b>Description</b> </td></tr>
<tr>
<th><code>ENVEL_USE</code> </th><td><code>bool</code> </td><td>true </td><td>Whether to compute convex/concave envelopes for the neither-convex-nor-concave univariate functions such as odd power terms, sin, cos, asin, acos, tan, atan, erf, erfc. This provides tighter McCormick relaxations, but it is more time consuming. Junction points are computed using the Newton or secant method first, then the more robust golden section search method if unsuccessful. </td></tr>
<tr>
<th><code>ENVEL_TOL</code> </th><td><code>double</code> </td><td>1e-10 </td><td>Termination tolerance for determination function points in convex/concave envelopes of univariate terms. </td></tr>
<tr>
<th><code>ENVEL_MAXIT</code> </th><td><code>int</code> </td><td>100 </td><td>Maximum number of iterations for determination function points in convex/concave envelopes of univariate terms. </td></tr>
<tr>
<th><code>MVCOMP_USE</code> </th><td><code>bool</code> </td><td>false </td><td>Whether to use Tsoukalas &amp; Mitsos's multivariate composition result for min/max, product, and division terms; see [Tsoukalas &amp; Mitsos, 2012]. This provides tighter McCormick relaxations, but it is more time consuming. </td></tr>
<tr>
<th><code>MVCOMP_TOL</code> </th><td><code>double</code> </td><td>1e1*machprec() </td><td>Tolerance for equality test in subgradient propagation for product terms with Tsoukalas &amp; Mitsos's multivariate composition result; see [Tsoukalas &amp; Mitsos, 2012]. </td></tr>
<tr>
<th><code>DISPLAY_DIGITS</code> </th><td><code>unsigned int</code> </td><td>5 </td><td>Number of digits in output stream </td></tr>
</table>
<h2><a class="anchor" id="sec_MC_err"></a>
What Errors Can Be Encountered during the Computation of Convex/Concave Bounds?</h2>
<p>Errors are managed based on the exception handling mechanism of the C++ language. Each time an error is encountered, a class object of type <a class="el" href="classmc_1_1McCormick_1_1Exceptions.html" title="Exceptions of mc::McCormick.">mc::McCormick::Exceptions</a> is thrown, which contains the type of error. It is the user's responsibility to test whether an exception was thrown during a McCormick relaxation, and then make the appropriate changes. Should an exception be thrown and not caught by the calling program, the execution will stop.</p>
<p>Possible errors encountered during the computation of a McCormick relaxation are:</p>
<table  border="1">
<caption align="bottom"><em>Errors during Computation of a McCormick relaxation</em></caption>
<tr>
<th><b>Number</b> </th><td><b>Description</b> </td></tr>
<tr>
<th><code>1</code> </th><td>Division by zero </td></tr>
<tr>
<th><code>2</code> </th><td>Inverse with zero in range </td></tr>
<tr>
<th><code>3</code> </th><td>Log with negative values in range </td></tr>
<tr>
<th><code>4</code> </th><td>Square-root with nonpositive values in range </td></tr>
<tr>
<th><code>5</code> </th><td>Inverse sine or cosine with values outside of \([-1,1]\) range </td></tr>
<tr>
<th><code>6</code> </th><td>Tangent with values outside of \([-\frac{\pi}{2}+k\pi,\frac{\pi}{2}+k\pi]\) range </td></tr>
<tr>
<th><code>-1</code> </th><td>Inconsistent size of subgradient between two <a class="el" href="classmc_1_1McCormick.html" title="C++ class for McCormick relaxation arithmetic for factorable function.">mc::McCormick</a> variables </td></tr>
<tr>
<th><code>-2</code> </th><td>Failed to compute the convex or concave envelope of a univariate term </td></tr>
<tr>
<th><code>-3</code> </th><td>Failed to propagate subgradients for a product term with Tsoukalas &amp; Mitsos's multivariable composition result </td></tr>
</table>
<h2><a class="anchor" id="sec_MC_refs"></a>
References</h2>
<ul>
<li>Bompadre, A., A. Mitsos, <a href="http://dx.doi.org/10.1007/s10898-011-9685-2">Convergence rate of McCormick relaxations</a>, <em>Journal of Global Optimization</em> <b>52</b>(1):1-28, 2012</li>
<li>McCormick, G. P., <a href="http://dx.doi.org/10.1007/BF01580665">Computability of global solutions to factorable nonconvex programs: Part I. Convex underestimating problems</a>, <em>Mathematical Programming</em>, <b>10</b>(2):147-175, 1976</li>
<li>Mitsos, A., B. Chachuat, and P.I. Barton, <a href="http://dx.doi.org/10.1137/080717341">McCormick-based relaxations of algorithms</a>, <em>SIAM Journal on Optimization</em>, <b>20</b>(2):573-601, 2009</li>
<li>Scott, J.K., M.D. Stuber, P.I. Barton, <a href="http://dx.doi.org/10.1007/s10898-011-9664-7">Generalized McCormick relaxations</a>. <em>Journal of Global Optimization</em>, <b>51</b>(4), 569-606, 2011</li>
<li>Tsoukalas, A., and A. Mitsos, <a href="http://www.optimization-online.org/DB_HTML/2012/05/3473.html">Multi-variate McCormick relaxations</a>, May 2012</li>
<li>Wechsung, A., and P.I. Barton, <a href="http://dx.doi.org/10.1007/s10898-013-0060-3">Global optimization of bounded factorable functions with discontinuities</a>, <em>Journal of Global Optimization</em>, <b>in press</b>, 2013</li>
</ul>
</div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Thu Jul 25 2013 13:28:41 for MC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
